# 둘만의 암호

## 📌 문제 설명

두 문자열 `s`, `skip`과 자연수 `index`가 주어진다.

### 규칙

1. 문자열 `s`의 각 알파벳을 `index`만큼 뒤의 알파벳으로 변경한다.
2. `z`를 넘어가면 다시 `a`로 돌아간다.
3. `skip`에 포함된 알파벳은 제외하고 건너뛴다.

---

## 🧠 풀이 아이디어

- `skip` 문자를 빠르게 확인하기 위해 boolean 배열 사용
- 각 문자마다 index만큼 이동
- 이동 시:
  - 알파벳을 한 칸씩 증가
  - `% 26` 연산으로 순환 처리
  - skip 문자가 아니면 count 증가
- 결과는 StringBuilder에 저장

---

## 💻 구현 코드 설명
알파벳  a~z 26개
1. `blocked[26]` 배열로 skip 문자 체크
2. 각 문자를 while문으로 index만큼 이동
3. 조건에 맞는 문자만 count 증가
4. 완성된 문자열 반환

---

## ⏱ 시간 복잡도

- O(N * index)
- N ≤ 50, index ≤ 20 → 충분히 빠름

---

## ✅ 예시

입력:

s = "aukks"
skip = "wbqd"
index = 5


출력:"happy"



### 🔎 변환 과정 요약

- a → h (b, d 제외)
- u → a
- k → p
- k → p
- s → y

최종 결과: `"happy"`

---

## 💡 핵심 포인트

- `% 26`으로 알파벳 순환 처리
- boolean 배열로 O(1) skip 체크
- StringBuilder로 문자열 효율적 생성
